name: "ðŸš€ Local Frontend Deploy (With IIS Map)"

on:
  workflow_dispatch:
    inputs:
      runner:
        description: "Select your runner"
        required: true
        type: choice
        default: "DESKTOP-IUAAE04"
        options:
          - DESKTOP-IUAAE04
          - host24-frontend
          - host24-backend
      domain:
        description: "Enter test folder name (e.g., local-test)"
        required: true
        default: "local-test"
      release_tag:
        description: "Enter GitHub Release tag (e.g., release/V10.0.3)"
        required: true

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ${{ fromJson('{"DESKTOP-IUAAE04":["self-hosted","Windows"],"host24-frontend":["self-hosted","frontend"],"host24-backend":["self-hosted","backend"]}')[github.event.inputs.runner] }}

    steps:
      - name: "Checkout Repository"
        uses: actions/checkout@v4

      - name: "Ensure GitHub CLI Installed"
        shell: powershell
        run: |
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            Write-Host "[INFO] GitHub CLI not found. Installing..."
            $version = "2.56.0"
            $zipUrl = "https://github.com/cli/cli/releases/download/v$version/gh_${version}_windows_amd64.zip"
            $zipPath = "$env:TEMP\ghcli.zip"
            $extractPath = "$env:ProgramData\ghcli"
            
            if (Test-Path $extractPath) { Remove-Item -Recurse -Force $extractPath }
            
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-WebRequest -Uri $zipUrl -OutFile $zipPath
            
            Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
            $ghExe = Get-ChildItem -Path $extractPath -Filter gh.exe -Recurse | Select-Object -First 1
            echo "$($ghExe.DirectoryName)" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            Write-Host "[OK] GitHub CLI is already installed."
          }

      - name: "Download ZIPs"
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "${{ github.event.inputs.release_tag }}"
          Write-Host "[INFO] Downloading assets for: $tag"
          $downloadDir = "$PWD\release_zips"
          if (Test-Path $downloadDir) { Remove-Item -Recurse -Force $downloadDir }
          New-Item -ItemType Directory -Path $downloadDir | Out-Null
          
          gh release download $tag --repo "${{ github.repository }}" --pattern "*.zip" --dir $downloadDir
          
          $count = (Get-ChildItem -Path $downloadDir -Filter *.zip).Count
          if ($count -eq 0) { Write-Error "[ERROR] No ZIPs found for $tag"; exit 1 }
          echo "download_dir=$downloadDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: "Extract ZIPs"
        id: extract
        shell: powershell
        run: |
          $source = "${{ steps.download.outputs.download_dir }}"
          $extractRoot = "$PWD\deploy"
          if (Test-Path $extractRoot) { Remove-Item -Recurse -Force $extractRoot }
          New-Item -ItemType Directory -Path $extractRoot | Out-Null
          
          $zips = Get-ChildItem -Path $source -Filter *.zip
          foreach ($zip in $zips) {
            # Logic from your file: Remove version number to get clean folder name
            # Example: release-V10.0.3-ag-app.zip -> ag-app
            $cleanName = ($zip.BaseName -replace 'release-V\d+\.\d+\.\d+-', '')
            
            # Fallback if replace didn't change anything (e.g. zip is just ag-app.zip)
            if ($cleanName -eq $zip.BaseName) { $cleanName = $zip.BaseName }

            $dest = Join-Path $extractRoot $cleanName
            Write-Host "[EXTRACT] $($zip.Name) -> $dest"
            Expand-Archive -Path $zip.FullName -DestinationPath $dest -Force
          }
          echo "extract_root=$extractRoot" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: "Deploy to IIS Domain (Mapped)"
        shell: powershell
        run: |
          $domain = "${{ github.event.inputs.domain }}"
          $root = "${{ steps.extract.outputs.extract_root }}"
          
          # ---------------------------------------------------------
          # ðŸ‘‡ CONFIG: Where should files go?
          # For LOCAL TEST use C:\Temp. For REAL SERVER use D:\inetpub
          # ---------------------------------------------------------
          $baseTarget = "C:\Temp\DeployTest\$domain"
          # $baseTarget = "D:\inetpub\vhosts\$domain\httpdocs" 
          
          # ðŸ‘‡ LOGIC: This is the Map from your Frontend.yml file
          $deployMap = @{
            "ag-app"              = "AG"
            "web-arborgold-crew"  = "Crew"
            "e-proposal"          = "EProposal"
            "e-invoice"           = "EInvoice"
            "e-statement"         = "EStatement"
          }

          Write-Host "==============================="
          Write-Host "DEPLOYING TO: $baseTarget"
          Write-Host "==============================="

          if (-Not (Test-Path $root)) { Write-Error "[ERROR] Source not found"; exit 1 }

          foreach ($key in $deployMap.Keys) {
             
             # 1. Find the source folder (e.g., looking for "ag-app")
             $srcPath = Join-Path $root $key
             
             # 2. Determine destination (e.g., "AG")
             $targetFolder = $deployMap[$key]
             $targetPath = Join-Path $baseTarget $targetFolder

             if (Test-Path $srcPath) {
                 if (-not (Test-Path $targetPath)) { New-Item -ItemType Directory -Force -Path $targetPath | Out-Null }
                 
                 Write-Host "[COPY] $key -> $targetFolder"
                 Copy-Item "$srcPath\*" -Destination $targetPath -Recurse -Force
             } else {
                 Write-Host "[WARN] Source folder '$key' not found in extracted files. Skipping."
             }
          }
          
          Write-Host "[SUCCESS] Deployment logic completed."

      - name: "Cleanup"
        if: always()
        shell: powershell
        run: |
          Remove-Item "$PWD\release_zips" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item "$PWD\deploy" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "[INFO] Cleanup done."
