name: "ðŸšš Manual Backend Deploy"

on:
  workflow_dispatch:
    inputs:
      host:
        description: "Select target host / runner"
        required: true
        type: choice
        options:
          - host24-backend
          - host24-frontend
          - host24-zip
          - DESKTOP-IUAAE04
          - AWS_Staging
          - AWS_PROD_01
          - AWS_PROD_02
          - AWS_PROD_03
          - AWS_PROD_04
          - AWS_PROD_05

      domain:
        description: "Comma-separated domain(s). Required."
        required: true

      exclude_domains:
        description: "Comma-separated domains to exclude manually"
        required: false

      restart_iis:
        description: "Restart IIS before & after Deployment?"
        required: false
        type: boolean
        default: false

      app_type:
        description: "Deployment Type"
        required: true
        type: choice
        options:
          - backend
          - frontend
          - both

      release_tag:
        description: "GitHub Release tag (e.g., release/V10.0.3)"
        required: true

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ${{ fromJson('{"host24-backend":["self-hosted","Windows","X64","host24","backend"],"host24-frontend":["self-hosted","Windows","X64","host24","frontend"],"host24-zip":["self-hosted","Windows","X64","host24","zip"],"DESKTOP-IUAAE04":["self-hosted","Windows","X64","DESKTOP-IUAAE04"],"AWS_Staging":["self-hosted","Windows","X64","AWS_Staging"],"AWS_PROD_01":["self-hosted","Windows","X64","AWS_PROD_01"],"AWS_PROD_02":["self-hosted","Windows","X64","AWS_PROD_02"],"AWS_PROD_03":["self-hosted","Windows","X64","AWS_PROD_03"],"AWS_PROD_04":["self-hosted","Windows","X64","AWS_PROD_04"],"AWS_PROD_05":["self-hosted","Windows","X64","AWS_PROD_05"]}')[github.event.inputs.host] }}
    steps:

      - name: "ðŸ“¥ Checkout Repository"
        uses: actions/checkout@v4

      # - name: "âš™ï¸ Ensure GitHub CLI Installed"
      #   shell: powershell
      #   run: |
      #     if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
      #       Write-Host "ðŸ“¦ Installing GitHub CLI..."
      #       $version = "2.56.0"
      #       $url = "https://github.com/cli/cli/releases/download/v$version/gh_${version}_windows_amd64.zip"
      #       $zip = "$env:TEMP\ghcli.zip"
      #       $dest = "$env:ProgramData\ghcli"
      #       if (Test-Path $dest) { Remove-Item -Recurse -Force $dest }
      #       Invoke-WebRequest -Uri $url -OutFile $zip
      #       Expand-Archive $zip $dest -Force
      #       $exe = Get-ChildItem $dest -Recurse -Filter gh.exe | Select-Object -First 1
      #       echo $exe.DirectoryName | Out-File $env:GITHUB_PATH -Append
      #       & "$($exe.FullName)" --version
      #     } else {
      #       Write-Host "âœ… GH CLI exists"
      #     }

      # - name: "ðŸ§¾ Download ZIP Assets"
      #   id: download
      #   shell: powershell
      #   env:
      #     GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   run: |
      #     $tag="${{ github.event.inputs.release_tag }}"
      #     Write-Host "ðŸ“¥ Downloading Release ZIPs for $tag..."
      #     gh release download $tag --repo "${{ github.repository }}" --pattern "*.zip" --clobber

      #     $downloadDir="$PWD/release_zips"
      #     if (Test-Path $downloadDir) { Remove-Item -Recurse -Force $downloadDir }
      #     New-Item -ItemType Directory -Path $downloadDir | Out-Null
      #     Move-Item *.zip $downloadDir -Force

      #     $count=(Get-ChildItem $downloadDir "*.zip").Count
      #     if ($count -eq 0) { Write-Error "âŒ No ZIP files found"; exit 1 }
      #     echo "download_dir=$downloadDir" >> $env:GITHUB_OUTPUT

      # - name: "ðŸ“¦ Extract ZIPs (Separately)"
      #   id: extract
      #   shell: powershell
      #   run: |
      #     $src = "${{ steps.download.outputs.download_dir }}"
      #     $extractRoot = "$PWD\deploy"
          
      #     if (Test-Path $extractRoot) { Remove-Item -Recurse -Force $extractRoot }
      #     New-Item -ItemType Directory -Path $extractRoot | Out-Null

      #     $zips = Get-ChildItem -Path $src -Filter *.zip
      #     foreach ($zip in $zips) {
      #       $folderName = ($zip.BaseName -replace 'release-V\d+\.\d+\.\d+-', '')
      #       if ([string]::IsNullOrWhiteSpace($folderName)) { $folderName = $zip.BaseName }
      #       $dest = Join-Path $extractRoot $folderName
      #       Write-Host "ðŸ“¦ Extracting $($zip.Name) â†’ $dest"
      #       Expand-Archive -Path $zip.FullName -DestinationPath $dest -Force
      #     }

      #     Write-Host "âœ… Extracted all ZIPs into $extractRoot"
      #     echo "extract_root=$extractRoot" >> $env:GITHUB_OUTPUT

      - name: "ðŸš€ Deploy to Domain(s)"
        id: deploy
        shell: powershell
        run: |
          Import-Module WebAdministration

          $rawDomains = "${{ github.event.inputs.domain }}"
          $rawExclude = "${{ github.event.inputs.exclude_domains }}"
          $restart    = "${{ github.event.inputs.restart_iis }}"
          $type       = "${{ github.event.inputs.app_type }}"
          $root       = "${{ steps.extract.outputs.extract_root }}"

          $deployMap = @{
            "ag-app" = "AG"; "web-arborgold-crew" = "Crew"; "e-proposal" = "EProposal"; "e-invoice" = "EInvoice"; "e-statement" = "EStatement"
          }

          if ([string]::IsNullOrWhiteSpace($rawDomains)) { Write-Error "âŒ ERROR: No domain provided."; exit 1 }

          $domains = $rawDomains.Split(",") | ForEach-Object { $_.Trim() }
          if (-not [string]::IsNullOrWhiteSpace($rawExclude)) {
            $exclude = $rawExclude.Split(",") | ForEach-Object { $_.Trim() }
            $domains = $domains | Where-Object { $exclude -notcontains $_ }
          }

          if ($domains.Count -eq 0) { Write-Host "âš ï¸ No domains to deploy."; exit 0 }

          $success = @(); $failed = @()

          foreach ($domain in $domains) {
            Write-Host "`nðŸš€ Deploying to $domain"
            $pool = $domain
            $httpdocs = "D:\inetpub\vhosts\$domain\httpdocs"

            if ($restart -eq "true" -and (Test-Path "IIS:\AppPools\$pool")) { Stop-WebAppPool $pool }

            try {
              $extractedFolders = Get-ChildItem -Path $root -Directory
              foreach ($folder in $extractedFolders) {
                $folderName = $folder.Name
                $targetSubFolder = ""
                $shouldDeploy = $false

                if ($deployMap.ContainsKey($folderName)) {
                   $targetSubFolder = $deployMap[$folderName]
                   if ($type -eq "frontend" -or $type -eq "both") { $shouldDeploy = $true }
                   else { Write-Host "â­ï¸ Skipping Frontend artifact: $folderName" }
                } else {
                   $targetSubFolder = "AG"
                   if ($type -eq "backend" -or $type -eq "both") { $shouldDeploy = $true; Write-Host "â„¹ï¸ Identified '$folderName' as Backend." }
                   else { Write-Host "â­ï¸ Skipping Backend artifact: $folderName" }
                }

                if ($shouldDeploy) {
                   $finalDest = Join-Path $httpdocs $targetSubFolder
                   Write-Host "ðŸ“‚ Deploying [$folderName] â†’ [$finalDest]"
                   if (-not (Test-Path $finalDest)) { New-Item -ItemType Directory -Path $finalDest -Force | Out-Null }
                   Copy-Item "$($folder.FullName)\*" -Destination $finalDest -Recurse -Force -ErrorAction Stop
                }
              }
              $success += $domain
            } catch {
              Write-Error "âŒ Failed $($domain): $_"
              $failed += $domain
            }

            if ((Test-Path "IIS:\AppPools\$pool") -and ($restart -eq "true" -or $failed -contains $domain)) { Start-WebAppPool $pool }
          }

          if ($restart -eq "true") { iisreset /restart }

          echo "success_domains=$($success -join ',')" >> $env:GITHUB_OUTPUT

      - name: "ðŸ§¹ Cleanup"
        if: always()
        shell: powershell
        run: |
          Remove-Item "$PWD/release_zips" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item "$PWD/deploy" -Recurse -Force -ErrorAction SilentlyContinue
